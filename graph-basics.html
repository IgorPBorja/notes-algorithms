<style>
body {
/*Reset the counter named theorem each time a body obj is instantiated*/
  counter-reset: theorem 0 definition 0 claim 0;
}
h1 {
/*Reset the counter named theorem each time a h1 obj is instantiated*/
  counter-reset: theorem 0 definition 0 claim 0; 
}

p.theorem::before {
  counter-increment: theorem; 
  content: "Teorema " counter(theorem) " \2014 "; 
}
p.theorem[data-attribution]::before {
  content: "Teorema " counter(theorem) " (" attr(data-attribution) ")  \2014 ";
}

p.claim::before {
  counter-increment: claim; 
  content: "Afirmação " counter(claim) " \2014 "; 
}

p.claim[data-attribution]::before {
  content: "Afirmação " counter(claim) " (" attr(data-attribution) ")  \2014 ";
}

p.definition::before {
  counter-increment: definition; 
  content: "Definição  " counter(definition) " \2014 "; 
}

p.definition[data-attribution]::before {
  content: "Definição " counter(definition) " (" attr(data-attribution) ")  \2014 ";
}
</style>

<script
src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
type="text/javascript"></script>

<h1 id="generic-graph-search">Generic graph search</h1>
<p>Entrada:</p>
<ul>
<li>Vértice inicial</li>
<li>Grafo</li>
</ul>
<p>Ideal: não olhar nenhum elemento mais do que um número limitado de
vezes (isto é, da ordem de <span class="math inline">\(O(|V| +
|E|)\)</span> ou melhor).</p>
<h2 id="algoritmo-ideia">Algoritmo (ideia)</h2>
<ul>
<li>Cada vértice deve estar associado a um booleano que indicará se já
foi visitado.</li>
<li>Marca-se o inicial, <span class="math inline">\(s\)</span>,
visitado.</li>
<li>Enquanto possível:
<ul>
<li>Escolha uma aresta <span class="math inline">\((u,v)\)</span> com
<span class="math inline">\(u\)</span> visitado e <span
class="math inline">\(v\)</span> não-visitado (fronteira): <strong>se
não existirem, termine execução</strong>.</li>
<li>Marcar <span class="math inline">\(v\)</span> visitado</li>
</ul></li>
</ul>
<strong>
<p class="claim">
Ao fim do algoritmo, <span class="math inline">\(v\)</span> está marcado
visitado se e só se existe um caminho <span class="math inline">\(s \to
v\)</span>
</p>
<p></strong> Prova: (<span class="math inline">\(\Rightarrow\)</span>)
(invariante de loop): Um resultado mais forte que vamos mostrar é que
essa condição não é satisfeita apenas ao término do algoritmo, mas é, de
fato, uma invariante de loop: <strong>ao final de cada iteração, o
conjunto de vértices marcados visitados é um subconjunto daqueles
alcançáveis a partir de</strong> <span
class="math inline">\(s\)</span>.</p>
<ul>
<li><strong>Na inicialização</strong>De fato, vale trivialmente no
início do algoritmo, pois apenas <span class="math inline">\(s\)</span>
foi visitado e existe um caminho de <span
class="math inline">\(s\)</span> a ele mesmo: o caminho vazio.</li>
<li><strong>Manutenção</strong>: Suponha que vale para a <span
class="math inline">\(k\)</span>-ésima iteração, portanto. Então na
<span class="math inline">\(k+1\)</span>-ésima iteração selecionamos uma
aresta <span class="math inline">\((u,v) \in G\)</span> com <span
class="math inline">\(u\)</span> visitado e <span
class="math inline">\(v\)</span> não. Como <span
class="math inline">\(u\)</span> foi marcado como visitado na <span
class="math inline">\(k\)</span>-ésima iteração ou antes, existe (por
hipótese de indução) um caminho <span class="math inline">\(s, a_1,
\dotsc, a_j, u\)</span> da fonte <span class="math inline">\(s\)</span>
a esse vértice. Portanto, quando <span class="math inline">\(v\)</span>
é posto como visitado, a invariante de loop se mantém, pois existe o
caminho <span class="math inline">\(s, a_1, \dotsc, a_j, u,
v\)</span>.</li>
<li>Portanto, ao término do algoritmo, a propriedade continua sendo
válida.</li>
</ul>
<p>(<span class="math inline">\(\Leftarrow\)</span>) Demonstração por
contradição: suponha que, após o término do algoritmo, existe <span
class="math inline">\(v\)</span> tal que <span
class="math inline">\(v\)</span> não foi visitado e existe caminho <span
class="math inline">\(a_1, \dotsc, a_k\)</span> de <span
class="math inline">\(s\)</span> a <span
class="math inline">\(v\)</span>, isto é, com <span
class="math inline">\(a_1 = s, a_k = v\)</span> e <span
class="math inline">\((a_i, a_{i+1}) \in G, \ \forall 1 \leq i &lt;
k\)</span>. Como o subconjunto de índices dos vértices desse caminho
(finito) que não foram visitados é não vazio (possui <span
class="math inline">\(k\)</span>), ele apresenta um menor elemento <span
class="math inline">\(j\)</span> (com <span class="math inline">\(j &gt;
1\)</span>, pois <span class="math inline">\(a_1 = s\)</span> foi
visitado).</p>
<p>Isto é, <span class="math inline">\(a_{j-1}\)</span> foi visitado,
<span class="math inline">\(a_j\)</span> não foi e a aresta <span
class="math inline">\((a_{j-1}, a_j)\)</span> pertence a <span
class="math inline">\(G\)</span>. Porém isso é uma contradição, uma vez
que o algoritmo não termina até não haverem mais arestas com o vértice
de saída visitado e o de destino não-visitado. Isso finaliza a
demonstração.</p>
<h1 id="implementações-do-algoritmo-anterior">Implementações do
algoritmo anterior</h1>
<p>Entretanto, o problema reside na linha:</p>
<p>“Escolha uma aresta <span class="math inline">\((u,v)\)</span> com
<span class="math inline">\(u\)</span> visitado e <span
class="math inline">\(v\)</span> não-visitado (fronteira): <strong>se
não existirem, termine execução</strong>.”</p>
<p>Como escolher essa aresta de forma eficiente? Daí, surgem as
implementações específicas, como BFS (Breadth-First-Search) e DFS
(Depth-First-Search).</p>
<h1 id="breadth-first-search">Breadth first Search</h1>
<p>Visita o grafo por camadas. Podemos definir as camadas de um grafo
(<strong>direcionado ou não</strong>) em referência a um vértice <span
class="math inline">\(s\)</span> recursivamente por:</p>
<ul>
<li>A camada <span class="math inline">\(0\)</span> contém apenas o
vértice <span class="math inline">\(s\)</span></li>
<li>A camada <span class="math inline">\(n+1\)</span> contém todos os
vértices que
<ul>
<li>São adjacentes a um vértice de camada <span
class="math inline">\(n\)</span>: isto é, existe <span
class="math inline">\(u\)</span> na camada <span
class="math inline">\(n\)</span> tal que existe a aresta <span
class="math inline">\((u, v)\)</span>.</li>
<li>Não estão na camada <span class="math inline">\(k\)</span> para
nenhum <span class="math inline">\(0 \leq k \leq n\)</span></li>
</ul></li>
</ul>
<p>Note uma correspondência direta entre essas camadas e os caminhos
mais curto a partir da fonte <span class="math inline">\(s\)</span>. De
fato, denote por <span class="math inline">\(d_s(v)\)</span> a camada na
qual se localiza o vértice <span class="math inline">\(s\)</span>, pondo
<span class="math inline">\(\infty\)</span> se não há tal camada, isto
é, se <span class="math inline">\(v\)</span> não está conectado, por
algum caminho, a <span class="math inline">\(s\)</span>.</p>
<strong>
<p class="claim">
O caminho mais curto de <span class="math inline">\(s\)</span> a <span
class="math inline">\(v\)</span> possui comprimento <span
class="math inline">\(n+1\)</span> (incluindo ambos os extremos) se e só
se <span class="math inline">\(v\)</span> está na camada <span
class="math inline">\(n\)</span>
</p>
<p></strong> Prova: Note que, se <span class="math inline">\(d_s(u) =
x\)</span>, e <span class="math inline">\((u, u&#39;)\)</span> está no
grafo, então <span class="math inline">\(d_s(u&#39;) \leq x +
1\)</span>, com a igualdade se e só se <span
class="math inline">\(u&#39;\)</span> não está em nenhuma das camadas
anteriores.</p>
<p>(<span class="math inline">\(\Rightarrow\)</span>) Seja <span
class="math inline">\(s, a_1, \dotsc, a_{n-1}, v\)</span> esse caminho
mínimo. Então temos que <span class="math inline">\(a_1\)</span> está na
camada <span class="math inline">\(1\)</span>, e portanto <span
class="math inline">\(d_s(a_2) \leq 2\)</span>. Indutivamente segue que
<span class="math inline">\(a_k \leq k\)</span> para todo $ 2 k n - 1$.
Consequentemente, devido à aresta <span class="math inline">\((a_{n-1},
v)\)</span>, <span class="math inline">\(d_s(v) \leq d_s(a_{n-1}) + 1 =
n\)</span>.</p>
<p>Suponha por contradição que ocorre a desigualdade estrita. Então
existe <span class="math inline">\(b_1\)</span> com <span
class="math inline">\(d_s(b_1) &lt; n - 1\)</span>. Indutivamente, segue
que existe <span class="math inline">\(b_i\)</span> com <span
class="math inline">\(d_s(b_i) &lt; n - i\)</span> para todo <span
class="math inline">\(1 \leq i \leq n - 1\)</span>. Logo</p>
<p><span class="math display">\[d_s(b_{n-1}) &lt; 1 \implies
d_s(b_{n-1}) = 0  \implies b_{n-1} = s\]</span></p>
<p>e portanto <span class="math inline">\(s, b_{n-2}, \dotsc, b_1,
v\)</span> é um caminho de tamanho <span class="math inline">\(n &lt; n
+ 1\)</span> de <span class="math inline">\(s\)</span> até <span
class="math inline">\(v\)</span>, o que contradiz a minimalidade do
caminho anterior apresentado.</p>
<p>(<span class="math inline">\(\Leftarrow\)</span>) Suponha que <span
class="math inline">\(d_s(v) = n\)</span>. Então, indutivamente, existe
<span class="math inline">\(a_i\)</span> tal que <span
class="math inline">\((a_i, a_{i-1})\)</span> pertence ao grafo e <span
class="math inline">\(d_s(a_i) = n - i\)</span>, com <span
class="math inline">\(a_0 := v\)</span>.</p>
<p>Logo, temos que <span class="math inline">\(d_s(a_n) = 0 \implies a_n
= s\)</span>, e assim <span class="math inline">\(s, a_{n-1}, \dotsc,
a_1, v\)</span> é um caminho de <span class="math inline">\(s\)</span> a
<span class="math inline">\(v\)</span>.</p>
<p>Por outro lado, suponha que existe um caminho mais curto <span
class="math inline">\(b_0 = s, b_1, \dotsc, b_{k-1}, b_{k} = v\)</span>
com <span class="math inline">\(k &lt; n + 1\)</span>. Então, como <span
class="math inline">\(d_s(b_1) = 1\)</span>, segue que (novamente por
indução) <span class="math inline">\(d_s(b_i) \leq i\)</span>, devido à
aresta <span class="math inline">\((b_{i-1}, b_i)\)</span> e à hipótese
indutiva. Concluímos <span class="math inline">\(d_s(b_k) = d_s(v) \leq
k &lt; n + 1\)</span> contradição. Em outras palavras, o caminho de
tamanho <span class="math inline">\(n+1\)</span> encontrado acima é
mínimo.</p>
<h2 id="implementação-da-bfs">Implementação da BFS</h2>
<pre><code>BFS(graph G, start vertex s)
    visited[s] = true
    q = empty queue
    insert s in q
    while q is not empty:
        remove front node of q and call it v
        for each edge(v, w)
            if visited[w] is false:
                visited[w] = true
                insert w in q</code></pre>
<h2 id="corretude">Corretude</h2>
<strong>
<p class="claim">
(Invariante de loop) Em cada iteração, todo vértice em <span
class="math inline">\(q\)</span> já foi visitado
</p>
<p></strong> Prova:</p>
<ul>
<li>Inicialização: <span class="math inline">\(q\)</span> possui apenas
o vértice <span class="math inline">\(s\)</span> quando criada, e esse
vértice já foi marcado como visitado no início do código.</li>
<li>Manutenção: elementos são adicionados na fila apenas na linha
“insert w in q”, a qual é precedida por marcar <span
class="math inline">\(w\)</span> como visitado. A invariante, portanto,
segue.</li>
</ul>
<strong>
<p class="claim">
Ao final do algoritmo, um vértice foi visitado se e só se existe um
caminho partindo de <span class="math inline">\(s\)</span> até ele
</p>
<p></strong> Prova: devido à afirmação anterior, e ao <code>if</code>
statment</p>
<p><code>ìf visited[w] is false: ...</code></p>
<p>toda aresta <span class="math inline">\((v, w)\)</span> de fato
percorrida pelo algoritmo satisfaz <span
class="math inline">\(visited[v] = true\)</span> e <span
class="math inline">\(visited[w] = false\)</span>. Portanto, é um caso
especial do modelo genérico da seção anterior, que já foi provado.</p>
<p>Isso mostra que a BFS visita um vértice se e só se ele está no
componente conectado do vértice de origem, o que é exatamente o que
queríamos demonstrar para mostrar a corretude da BFS.</p>
<h2 id="característica-de-busca-em-largura">Característica de busca em
largura</h2>
<strong>
<p class="theorem">
Se <span class="math inline">\(d_s(u) &lt; d_s(v) &lt; \infty\)</span>
então <span class="math inline">\(u\)</span> foi marcado como visitado
antes de <span class="math inline">\(v\)</span>. Isto é, os vértices são
visitados em ordem crescente de camadas
</p>
<p></strong> Prova:</p>
<p>Note que, como o vértice visitado é sempre aquele retirado da frente
da fila, a ordem dos vértices visitados é a ordem dos vértices que
entraram na fila: isto é, se os vértices foram visitados na ordem <span
class="math inline">\(v_{\sigma(1)}, \dotsc, v_{\sigma(n)}\)</span>, com
<span class="math inline">\(v_{\sigma(1)} = s\)</span> evidentemente,
então os vértices foram adicionados na fila nessa mesma ordem.</p>
<p>Assim, podemos agora seguir a demonstração por indução. O caso base é
o grafo com um único vértice no componente conectado de <span
class="math inline">\(s\)</span>: o próprio <span
class="math inline">\(s\)</span>, e nesse caso o teorema é trivial.
Suponha, então, válida a afirmação para todo grafo <span
class="math inline">\(M\)</span> com <span class="math inline">\(max_{v
\in M}d_s(v) \leq n\)</span>. Seja então <span
class="math inline">\(G\)</span> um grafo em que <span
class="math inline">\(max_{v \in G}d_s(v) = n + 1\)</span>.</p>
<p>Sejam <span class="math inline">\(u_i, 1 \leq i \leq k\)</span> os
vértices que estão na <span class="math inline">\((n+1)\)</span>-ésima
camada. Então cada <span class="math inline">\(u_i\)</span> é adicionado
após visitar um vértice na <span class="math inline">\(n\)</span>-ésima
camada. Porém, pela hipótese de indução, os vértices no subgrafo <span
class="math inline">\(G_{u_1, \dotsc, u_k}\)</span> são visitados em
ordem crescente de camada e, portanto, visita-se <span
class="math inline">\(s\)</span>, depois todos os vértices da camada
<span class="math inline">\(1\)</span> (em alguma ordem), <span
class="math inline">\(\dotsc\)</span>, depois todos os vértices da
camada <span class="math inline">\(n\)</span>, em alguma ordem. Assim,
quando um vértice <span class="math inline">\(u_i\)</span> é adicionado
no <strong>fim</strong> da fila, todos os vértices <span
class="math inline">\(v\)</span> que satisfazem <span
class="math inline">\(d_s(v) \leq n\)</span> já foram visitados (e
removidos da fila) ou ainda estão na fila, na frente de <span
class="math inline">\(u_i\)</span>, e serão visitados primeiro por
isso.</p>
<p>Logo, a propriedade do teorema se mantém para grafos de camada máxima
<span class="math inline">\(n+1\)</span>, provando-o por indução.</p>
<h2 id="complexidade">Complexidade</h2>
<strong>
<p class="theorem">
A complexidade da implementação acima do algoritmo de
Breadth-First-Search é <span class="math inline">\(O(|V_s| +
|E_s|)\)</span>, onde <span class="math inline">\(|V_s|\)</span> é a
quantidade de vértices no componente conectado de <span
class="math inline">\(s\)</span> e <span
class="math inline">\(|E_s|\)</span> a quantidade de arestas do
componente conectado de <span class="math inline">\(s\)</span>.
</p>
</strong> Prova: Podemos considerar o algoritmo agindo apenas no
subgrafo que representa o componente conectado que contém <span
class="math inline">\(s\)</span>, pois pela Afirmação 2 da seção
“Corretude”, um vértice é visitado se e só se ele está nesse componente.
Ademais, uma aresta que não faz parte desse componente que contém <span
class="math inline">\(s\)</span> envolve, necessariamente, dois vértices
que não fazem parte desse componente e, com isso, nunca poderia ter sido
analisada. Com isso, temos: <strong>
<p class="claim">
Todo vértice é visitado somente uma vez
</p>
<p></strong></p>
<div style="margin-left: 3%;">
<p>Se <span class="math inline">\(v\)</span> fosse visitado duas ou mais
vezes, isso quer dizer que ele foi colocado (pelo menos) uma segunda vez
na fila, isto é, existem duas arestas <span class="math inline">\(e_1 =
(u_1, v)\)</span> e <span class="math inline">\(e_2 = (u_2, v)\)</span>
que o algoritmo visita e que foram usadas para inserir <span
class="math inline">\(v\)</span> na fila. Suponha sem perda de
generalidade que <span class="math inline">\(e_1\)</span> é analisada
antes de <span class="math inline">\(e_2\)</span>. Então ao analisar
<span class="math inline">\(e_1\)</span> e inserir <span
class="math inline">\(v\)</span> na fila, <span
class="math inline">\(v\)</span> é marcado como visitado.</p>
<p>Porém isso implica que, olhando para as adjacências de <span
class="math inline">\(u_2\)</span>, o algoritmo inseriu <span
class="math inline">\(v\)</span> com <span
class="math inline">\(visited[v] = true\)</span>, o que contradiz a
implementação dada! Logo cada vértice só pode ser visitado uma única
vez.</p>
<p>Note que podemos ter inclusive <span class="math inline">\(u_1 =
u_2\)</span> (no caso de múltiplas arestas entre dois vértices) e
demonstração continua valendo da mesma maneira.</p>
</div>
<strong>
<p class="claim">
Cada aresta é analisada uma única vez
</p>
<p></strong></p>
<div style="margin-left: 3%;">
<p>Seja <span class="math inline">\((u,v) \in E_s\)</span> uma aresta
com, sem perda de generalidade, <span class="math inline">\(u\)</span>
sendo visitado primeiro que <span class="math inline">\(v\)</span>.
Então a aresta é analisada (apenas uma única vez) quando o algoritmo
está iterando sobre a adjacência de <span
class="math inline">\(v\)</span> e, nesse instante, <span
class="math inline">\(v\)</span> é marcado visitado. Note que, pela
afirmação anterior, <span class="math inline">\(u\)</span> não é
visitado novamente, e portanto a aresta <span
class="math inline">\((u,v)\)</span> não é mais analisada a partir de
<span class="math inline">\(u\)</span> - o que já é suficiente para
finalizar a demonstração, no caso de grafos direcionados.</p>
<p><em>No caso do grafo ser não-direcionado</em>, basta observar que, ao
visitar <span class="math inline">\(v\)</span> e iterar sobre sua
adjacência, como <span class="math inline">\(u\)</span> já foi marcado
como visitado, o algoritmo não vai passar pela aresta <span
class="math inline">\((v,u)\)</span>.</p>
</div>
<p>Portanto, segue que a complexidade do algoritmo é <span
class="math inline">\(O(|V_s| + |E_s|)\)</span> como queríamos
demonstrar.</p>
<h1
id="calculando-componentes-conectados-em-grafos-não-direcionados-com-bfs">Calculando
componentes conectados em grafos não direcionados com BFS</h1>
<h2
id="por-que-não-direcionado-definindo-e-entendendo-componentes-conectados">Por
que “não-direcionado”?: definindo e entendendo componentes
conectados</h2>
<p>Intuitivamente, pensamos em componentes conectados como as “peças” de
um grafo: conjunto de vértices que estão todos interligados. Mais
precisamente, queremos que, dentro de um mesmo componente conectado,
entre quaisquer dois vértices sempre exista um caminho.</p>
<p>Entretanto, conforme veremos, essa ideia, ao ser aplicada para grafos
<strong>direcionados</strong>, não é compatível com a definição que
daremos a seguir, a qual é a mais útil para os algoritmos de
conectividade a seguir.</p>
<strong>
<p class="definition">
Dados dois vértices <span class="math inline">\(u, v\)</span>, definimos
a relação de equivalência <span class="math inline">\(\sim\)</span> por:
<span class="math inline">\(u \sim v \iff \text{ existe um caminho de }
u \text{ até } v\)</span>
</p>
<p></strong></p>
<strong>
<p class="theorem">
Para grafos <em>não direcionados</em>, a relação <span
class="math inline">\(\sim\)</span> definida acima é uma relação de
equivalência.
</p>
<p></strong> Prova: para todo o grafo, direcionado ou não, temos que
<span class="math inline">\(\sim\)</span> é reflexiva (basta considerar
o caminho sem arestas) e é transitiva, pois se <span
class="math inline">\(u \sim v\)</span> com um caminho <span
class="math inline">\(u \to a_1 \to \dotsc \to a_n \to v\)</span> e
<span class="math inline">\(v \sim w\)</span> com um caminho <span
class="math inline">\(v \to b_1 \to \dotsc \to b_m \to w\)</span>, então
<span class="math inline">\(u \sim w\)</span> com o caminho <span
class="math display">\[u \to a_1 \to \dotsc a_n \to v \to b_1 \to \dotsc
\to b_m \to w\]</span></p>
<p>Porém, se <span class="math inline">\(u \sim v\)</span>, apenas para
grafos <strong>não direcionados</strong> teremos necessariamente <span
class="math inline">\(v \sim u\)</span> (cujo caminho associado é o
mesmo de <span class="math inline">\(u\)</span> a <span
class="math inline">\(v\)</span>, com o sentido das arestas invertidas).
De fato, para grafos direcionados temos o contra-exemplo simples do
seguinte grafo-linha: <span class="math inline">\(G_1 = (V_1,
E_1)\)</span> com <span class="math inline">\(V_1 = {1, 2, 3}\)</span>
<span class="math inline">\(E_1 = {(1, 2), (2, 3)}\)</span></p>
Agora, podemos definir os componentes conectados. <strong>
<p class="definition">
Dado um grafo <span class="math inline">\(G = (V, E)\)</span> definimos
seus componentes conectados como o conjunto quociente <span
class="math inline">\(V/\sim\)</span>
</p>
<p></strong></p>
<h2 id="implementação-e-análise">Implementação e análise</h2>
<pre><code>connected_components(Graph G)
    for s in V:
        if visited[s] is false:
            BFS(G, s)</code></pre>
<p>Esse algoritmo garantidamente visita todos os vértices e arestas de
<span class="math inline">\(G\)</span>, devido à BFS visitar todos os
vértices (e, logo, arestas) do componente conectado de <span
class="math inline">\(v\)</span>, e marcá-los como visitados.</p>
<strong>
<p class="theorem">
Esse algoritmo é $O(|V| + |E|)
</p>
<p></strong> Prova: se <span class="math inline">\(G\)</span> possui
<span class="math inline">\(k\)</span> componentes conectados <span
class="math inline">\(G_1,\dotsc, G_k\)</span>, então para todo <span
class="math inline">\(G_i\)</span> com <span class="math inline">\(1
\leq i \leq k\)</span>, na primeira vez em que se realizar a BFS em um
vértice desse componente, todos os seus vértices são marcados como
visitados, e portanto nenhuma BFS visitará esse componente de novo.</p>
<p>Isso mostra que exatamente <span class="math inline">\(k\)</span>
BFSs são realizadas, cada uma com complexidade <span
class="math inline">\(O(|V_i| + |E_i|)\)</span>, onde <span
class="math inline">\(|V_i|\)</span> e <span
class="math inline">\(|E_i|\)</span> são a quantidade de vértices e
arestas do <span class="math inline">\(i\)</span>-ésimo componente.
Assim</p>
<p><span class="math display">\[O(connected\_components) = \sum_{1 \leq
i \leq k}O(|V_k| + |E_k|) = O(\sum_{1 \leq i \leq k}|V_k| + \sum_{1 \leq
i \leq k}|E_k|) = O(|V| + |E|)\]</span> mostrando que o algoritmo é
<span class="math inline">\(O(|V| + |E|)\)</span>, como queríamos.</p>
<h2 id="adaptações">Adaptações</h2>
<p>Todas as adaptações a seguir mantém a complexidade do algoritmo
intacta.</p>
<h3 id="calculando-o-número-de-componentes-conectados">Calculando o
número de componentes conectados</h3>
<pre><code>connected_components(Graph G)
    num = 0
    for s in V:
        if visited[s] is false:
            BFS(G, s)
            num = num + 1
    return num</code></pre>
<h3 id="calculando-o-tamanho-de-cada-componente-conectado">Calculando o
tamanho de cada componente conectado</h3>
<pre><code>BFS_measure_component(graph G, start vertex s)
    component_size = 0
    visited[s] = true
    q = empty queue
    insert s in q
    while q is not empty:
        remove front node of q and call it v
        for each edge(v, w)
            if visited[w] is false:
                visited[w] = true
                component_size = component_size + 1
                insert w in q
    return component_size

connected_components(Graph G)
    sizes = []
    for s in V:
        if visited[s] = false:
            insert BFS_measure_component(G, s) in sizes
    return sizes</code></pre>
<p>Essa implementação adiciona a repetição da operação de adicionar um
elemento ao vetor <span class="math inline">\(sizes\)</span> um total de
<span class="math inline">\(k\)</span> vezes, em que <span
class="math inline">\(k\)</span> é a quantidade de componentes
conectados. Como <span class="math inline">\(k \leq |V|\)</span>, temos
que essa implementação é <span class="math inline">\(O(|V| + |E| + k) =
O(|V| + |E|)\)</span> como todas as outras.</p>
<h3 id="calculando-os-componentes-conectados-em-si">Calculando os
componentes conectados em si</h3>
<pre><code>BFS_get_component(graph G, start vertex s)
    component = []
    visited[s] = true
    q = empty queue
    insert s in q
    while q is not empty:
        remove front node of q and call it v
        for each edge(v, w)
            if visited[w] is false:
                visited[w] = true
                insert w in component
                insert w in q
    return component

connected_components(Graph G)
    components = []
    for s in V:
        if visited[s] = false:
            insert BFS_get_component(G, s) in components
    return components</code></pre>
<p>A diferença dessa implementação é que cada vértice é inserido
exatamente uma vez (na BFS do seu respectivo componente), e cada
componente (vetor) é adicionado uma vez à matriz <span
class="math inline">\(components\)</span> - o que gera mais <span
class="math inline">\(O(|V| + k)\)</span> operações, em que <span
class="math inline">\(k\)</span> é a quantidade de componentes
conectados. Como <span class="math inline">\(k \leq |V|\)</span>, o
algoritmo é <span class="math inline">\(O(|V| + |E| + |V| + k) = O(|V| +
|E|)\)</span>, como todas as outras implementações.</p>
